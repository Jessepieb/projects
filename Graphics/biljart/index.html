<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Three.js practice</title>
    <link type="text/css" rel="stylesheet" href="index.css">
</head>
<body>
<div id="scoreboard">test</div>
<div id="EvenColor" style="font-size: 30px"></div>
<div id="OddColor" style="font-size: 30px"></div>
<div id="WinText" style="font-size: 80px"></div>
<div id="controls">Use WASD for aim and power & 'space' to launch</div>
<script src="js/three.js"></script>
<script src="Table.js"></script>
<script src="Ball.js"></script>
<script src="Wall.js"></script>
<script src="Pocket.js"></script>
<script src="Que.js"></script>
<script src="Player.js"></script>
<script src="js/OrbitControls.js"></script>
<script>

    let camera, renderer, scene;
    const width = window.innerWidth;
    const height = window.innerHeight;

    let balls = [];
    const radius = 0.8;

    let table;
    let que;
    let moving = false;
    let players = [];

    let controls;

    let raycaster = new THREE.Raycaster();
    let mouse = new THREE.Vector2();

    function initCamera() {
        camera = new THREE.PerspectiveCamera(110, width / height, 0.5, 1000);
        camera.position.z = 15;
    }

    function initRenderer() {
        renderer = new THREE.WebGLRenderer();
        renderer.setSize(width,height);
    }

    function initControls() {
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

    }

    function initBalls() {
        let x, y;
        let offset = radius * 2;
        let count = 0;
        let isOdd = false;
        let newBall;

        for (let j = 5; j > 0; j--) {
            for (let i = j * -0.5; i < j / 2.0; i++) {
                y = 0 - (offset * (i + 0.5));
                x = -5 - (offset * j);
                if (count === 10) {
                    newBall = new Ball(x, y, radius, scene, "black");
                    balls.push(newBall);
                } else {
                    let balltype = "";
                    if (isOdd) {
                        balltype = "odd";
                    } else {
                        balltype = "even";
                    }
                    newBall = new Ball(x, y, radius, scene, balltype);
                    balls.push(newBall);
                    isOdd = !isOdd;
                }
                count++;
            }
        }
    }

    function initTable() {
        table = new Table(width, height, scene);
    }

    function initPlayers() {
        let player = new Player("Player1", true);
        players.push(player);
        player = new Player("player2", false);
        players.push(player);
    }

    function init() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color('darkgrey');

        initTable();
        const ball = new Ball(14, 0, radius, scene);
        balls.push(ball);
        initBalls();
        que = new Que(balls[0], scene);

        raycaster = new THREE.Raycaster()
        initPlayers();
        initCamera();
        initRenderer();

        initControls();

        document.body.appendChild(renderer.domElement);
    }



    document.onkeydown = checkKey;
    let force = new THREE.Vector2(0,0);
    var shot = false;
    function checkKey(e) {
        e = e || window.event;
        if (e.key === 'w') {
            force.add(new THREE.Vector2(0, balls[0].radius/50));
        } else if (e.key === 's') {
            force.add(new THREE.Vector2(0, -balls[0].radius/50));
        } else if (e.key === 'a') {
            force.add(new THREE.Vector2(-balls[0].radius/50, 0));

        } else if (e.key === 'd') {
            force.add(new THREE.Vector2(balls[0].radius/50, 0));
        }

        else if(e.keyCode === 32){
            balls[0].velocity = (force);
            force = new THREE.Vector2(0,0);
            shot = true;
        }
        que.location = force;
    }

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    })

    window.addEventListener('mousemove', (event) => {
        mouse.x = event.x / window.innerWidth * 2 - 1;
        mouse.y = event.y / window.innerHeight * 2 - 1;
    })

    function getCurrentPlayer() {
        return !!players[0].turn;
    }

    function Collision() {
        for (let i = 0; i < balls.length; i++) {
            if (balls[i] !== undefined) {
                table.Collide(balls[i]);
                for (let b = i+1; b < balls.length; b++) {
                    if (i !== b || balls[b]!==undefined) {
                        balls[i].checkCollision(balls[b]);
                    }
                }
                for (let p = 0; p < 3; p++) {
                    try {
                        let curPlay = getCurrentPlayer() ? 0:1;
                        let othPlay = getCurrentPlayer() ? 1:0;
                        if (table.pockets[p][0].Collide(balls[i], balls.length, players[curPlay], players[othPlay]) ||
                            table.pockets[p][1].Collide(balls[i], balls.length, players[curPlay], players[othPlay])) {
                            console.log(players);
                            scene.remove(balls[i].mesh)
                            scene.remove(balls[i].geometry);

                            balls[i] = undefined;
                            break;
                        }
                    } catch (e) {
                        console.log(e.toString());
                    }
                }
            }
        }
    }

    function updateMovement() {
        for (let i = 0; i < balls.length; i++) {
            if(balls[i] !== undefined){
            balls[i].Move();}
        }
        Collision();
    }

    var scored= false;

    function animate() {
       if (!Pocket.checkIsMoving()&&shot){
            que.visible = true;
            que.location = force;
            if (!scored)
            {
                players[0].turn = !players[0].turn;
                players[1].turn = !players[1].turn;
                scored = false;
                shot = false;
            }
           else {
               scored=false;
               shot=false;
            }}
        else{
            que.visible = false;
            que.location = force;
        }
        requestAnimationFrame(animate);
        updateMovement();
        raycaster.setFromCamera(mouse, camera);
        controls.update();
        var currentPlayer = getCurrentPlayer() ? 0:1;
        document.getElementById("scoreboard").innerHTML =
            "Player 1 score: " + players[0].score + "<br/>"+
            "Player 2 score: " + players[1].score + "<br/>"+
            players[currentPlayer].name +"'s Turn";
        renderer.render(scene, camera);
    }

    init();
    animate();
</script>
</body>
</html>