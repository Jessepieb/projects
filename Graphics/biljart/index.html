<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Three.js practice</title>
    <style>
        html, body {
            margin: 0px;
        }

        canvas {
            position: absolute;
            overflow: hidden;
        }
    </style>
</head>
<body>

<!--<div id="label" style="position: absolute; color: black"></div>-->
<script src="js/three.js"></script>
<script src="Table.js"></script>
<script src="Ball.js"></script>
<script src="Wall.js"></script>
<script src="Pocket.js"></script>
<script src="Que.js"></script>
<script src="js/OrbitControls.js"></script>
<script>

    var camera, renderer, scene;
    const width = window.innerWidth;
    const height = window.innerHeight;

    var balls = [];
    const radius = 0.8;

    var table, que;

    let controls;

    let raycaster = new THREE.Raycaster();
    var mouse = new THREE.Vector2();


    function initCamera() {
        camera = new THREE.PerspectiveCamera(100, width / height, 0.5, 1000);
        camera.position.z = 15;
    }

    function initRenderer() {
        renderer = new THREE.WebGLRenderer();
        renderer.setSize(width, height);

    }

    function initControls() {
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

    }

    function initBalls() {
        var x, y;
        var offset = radius * 2.1;
        let count = 0;
        let isOdd = false;

        for (let j = 5; j > 0; j--) {
            for (let i = j * -0.5; i < j / 2.0; i++) {
                y = 0 - (offset * (i + 0.5));
                x = -5 - (offset * j);
                if (count == 10) {
                    var newBall = new Ball(x, y, radius, scene, "black");
                    balls.push(newBall);
                } else {
                    var ballsort;
                    if (isOdd) {
                        ballsort = "odd";
                    } else {
                        ballsort = "even";
                    }
                    var newBall = new Ball(x, y, radius, scene, ballsort);
                    balls.push(newBall);
                    isOdd = !isOdd;
                }
                count++;
            }
        }
    }

    function initTable() {
        table = new Table(width, height, scene);
    }

    function init() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color('lightgray');

        initTable();
        const ball = new Ball(14, 0, radius, scene);
        balls.push(ball);
        initBalls();
        //  var que = new Que(ball.location.x,ball.location.y, scene);

        raycaster = new THREE.Raycaster()

        initCamera();
        initRenderer();

        initControls();

        document.body.appendChild(renderer.domElement);
    }

    document.onkeydown = checkKey;

    function checkKey(e) {
        e = e || window.event;
        if (e.keyCode == '38') {
            balls[0].applyForce(new THREE.Vector2(0, 0.06));
        } else if (e.keyCode == '40') {
            balls[0].applyForce(new THREE.Vector2(0, -0.06));
        } else if (e.keyCode == '37') {
            // balls[0].mesh.rotate.x += 1;
            balls[0].applyForce(new THREE.Vector2(-0.06, 0));

        } else if (e.keyCode == '39') {
            balls[0].applyForce(new THREE.Vector2(0.06, 0));
        }


    }

    window.addEventListener('resize', () => {
        renderer.setSize(window.innerWidth, window.innerHeight);
        camera.aspect = window.innerWidth / window.innerHeight;

        camera.updateProjectionMatrix();
    })
    //
    // window.addEventListener('mousedown',() =>{
    //     que.location = new THREE.Vector2(mouse.x,mouse.y);
    // })

    window.addEventListener('mousemove', (event) => {
        mouse.x = event.x / window.innerWidth * 2 - 1;
        mouse.y = event.y / window.innerHeight * 2 - 1;
    })

    function checkCollision() {
        for (let i = 0; i < balls.length; i++) {
            table.Collide(balls[i]);

            for (let j = 0; j < balls.length; j++) {
                if (i !== j) {
                    balls[i].Collide(balls[j]);
                }
                balls[j].Move();
            }

            for (let p = 0; p < 3; p++) {
                try {
                    if (table.pockets[p][0].Collide(balls[i], balls.length) ||
                        table.pockets[p][1].Collide(balls[i], balls.length)) {
                        //scene.remove(balls[i].mesh.name);
                        balls[i].mesh.remove();
                    }
                } catch (e) {
                    console.log(e.toString());
                }
            }
        }
    }

    function updateMovement() {
        for (let i = 0; i < balls.length; i++) {
            balls[i].Move();
        }
    }

    function animate() {
        requestAnimationFrame(animate);

        raycaster.setFromCamera(mouse, camera);

        checkCollision();
        updateMovement();
        controls.update();
        // document.getElementById("label").innerHTML = balls[0].location.toArray().toString();
        renderer.render(scene, camera);
    }

    init();
    animate();
</script>
</body>
</html>