<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Three.js practice</title>
    <style>
        html, body {
            margin: 0;
        }

        canvas {
            position: absolute;
            overflow: hidden;
        }
    </style>
</head>
<body>

<!--<div id="label" style="position: absolute; color: black"></div>-->
<script src="js/three.js"></script>
<script src="Table.js"></script>
<script src="Ball.js"></script>
<script src="Wall.js"></script>
<script src="Pocket.js"></script>
<script src="Que.js"></script>
<script src="Player.js"></script>
<script src="js/OrbitControls.js"></script>
<script>

    let camera, renderer, scene;
    const width = window.innerWidth;
    const height = window.innerHeight;

    let balls = [];
    const radius = 0.8;

    let table;
    let que;
    let moving = false;
    let players = [];

    let controls;

    let raycaster = new THREE.Raycaster();
    let mouse = new THREE.Vector2();

    function initCamera() {
        camera = new THREE.PerspectiveCamera(110, width / height, 0.5, 1000);
        camera.position.z = 15;
    }

    function initRenderer() {
        renderer = new THREE.WebGLRenderer();
        renderer.setSize(width, height);

    }

    function initControls() {
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

    }

    function initBalls() {
        let x, y;
        let offset = radius * 2;
        let count = 0;
        let isOdd = false;
        let newBall;

        for (let j = 5; j > 0; j--) {
            for (let i = j * -0.5; i < j / 2.0; i++) {
                y = 0 - (offset * (i + 0.5));
                x = -5 - (offset * j);
                if (count === 10) {
                    newBall = new Ball(x, y, radius, scene, "black");
                    balls.push(newBall);
                } else {
                    let balltype = "";
                    if (isOdd) {
                        balltype = "odd";
                    } else {
                        balltype = "even";
                    }
                    newBall = new Ball(x, y, radius, scene, balltype);
                    balls.push(newBall);
                    isOdd = !isOdd;
                }
                count++;
            }
        }
    }

    function initTable() {
        table = new Table(width, height, scene);
    }

    function initPlayers() {
        let player = new Player("Player1", true);
        players.push(player);
        player = new Player("player2", false);
        players.push(player);
    }

    function init() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color('darkgrey');

        initTable();
        const ball = new Ball(14, 0, radius, scene);
        balls.push(ball);
        initBalls();
        que = new Que(balls[0], scene);

        raycaster = new THREE.Raycaster()
        initPlayers();
        initCamera();
        initRenderer();

        initControls();

        document.body.appendChild(renderer.domElement);
    }



    document.onkeydown = checkKey;
    let force = new THREE.Vector2(0,0);
    function checkKey(e) {
        // e = e || window.event;
        // if (e.key === 'w') {
        //     balls[0].applyForce(new THREE.Vector2(0, 0.5));
        // } else if (e.key === 's') {
        //     balls[0].applyForce(new THREE.Vector2(0, -0.5));
        // } else if (e.key === 'a') {
        //     // balls[0].mesh.rotate.x += 1;
        //     balls[0].applyForce(new THREE.Vector2(-0.5, 0));
        //
        // } else if (e.key === 'd') {
        //     balls[0].applyForce(new THREE.Vector2(0.5, 0));
        // }
        e = e || window.event;
        if (e.key === 'w') {
            force.add(new THREE.Vector2(0, 0.5));
        } else if (e.key === 's') {
            force.add(new THREE.Vector2(0, -0.5));
        } else if (e.key === 'a') {
            // balls[0].mesh.rotate.x += 1;
            force.add(new THREE.Vector2(-0.5, 0));

        } else if (e.key === 'd') {
            force.add(new THREE.Vector2(0.5, 0));
        }

        else if(e.keyCode === 32){
            balls[0].applyForce(force);
            force = new THREE.Vector2(0,0);
        }
        console.log(force);
        que.location = force;
    }

    window.addEventListener('resize', () => {
        renderer.setSize(window.innerWidth, window.innerHeight);
        camera.aspect = window.innerWidth / window.innerHeight;

        camera.updateProjectionMatrix();
    })

     // window.addEventListener('mousedown',() =>{
     //     que.location = new THREE.Vector2(mouse.x,mouse.y);
     // })

    window.addEventListener('mousemove', (event) => {
        mouse.x = event.x / window.innerWidth * 2 - 1;
        mouse.y = event.y / window.innerHeight * 2 - 1;
    })

    function getCurrentPlayer() {
        return players[0].turn ? true : false;
    }


    function Collision() {
        for (let i = 0; i < balls.length; i++) {
            if (balls[i] !== undefined) {
                table.Collide(balls[i]);
                for (let b = i+1; b < balls.length; b++) {
                    if (i !== b || balls[b]!==undefined) {
                        balls[i].checkCollision(balls[b]);
                    }
                }
                for (let p = 0; p < 3; p++) {
                    try {
                        let curPlay = getCurrentPlayer() ? 0:1;
                        let othPlay = getCurrentPlayer() ? 1:0;
                        if (table.pockets[p][0].Collide(balls[i], balls.length, players[curPlay], players[othPlay]) ||
                            table.pockets[p][1].Collide(balls[i], balls.length, players[curPlay], players[othPlay])) {
                            console.log(players);
                            scene.remove(balls[i].mesh)
                            scene.remove(balls[i].geometry);

                            balls[i] = undefined;
                            console.log(balls);
                            break;
                        }
                    } catch (e) {
                        console.log(e.toString());
                    }
                }
            }
        }
    }

    function updateMovement() {
        for (let i = 0; i < balls.length; i++) {
            if(balls[i] !== undefined){
            balls[i].Move();}
        }
        Collision();
    }


    function animate() {
        // moving = false;
        // for (let i = 0; i < balls.length; i++){
        //     if (balls[i] !== undefined){
        //         const ball = balls[i];
        //         if (balls[i].velocity.x != 0 || balls[i].velocity.y != 0){
        //             moving = true
        //             break;
        //         }
        //     }
        // }
        // if (moving){
        //     que.visible = false;
        // }
        // else{
        //     que.visible = true;
        // }
        if (balls[0].velocity === new THREE.Vector2(0,0)){
            que.location = force;
        }
        requestAnimationFrame(animate);
        updateMovement();
        raycaster.setFromCamera(mouse, camera);
        controls.update()
        // document.getElementById("label").innerHTML = balls[0].location.toArray().toString();
        renderer.render(scene, camera);
    }

    init();
    animate();
</script>
</body>
</html>